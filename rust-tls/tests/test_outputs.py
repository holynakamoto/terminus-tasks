"""Tests for Rust TLS build configuration task."""
import subprocess
import re
import os
import pathlib

def test_cargo_build_succeeds():
    """Verify cargo build completes successfully."""
    result = subprocess.run(
        ["cargo", "build", "--release"],
        cwd="/app",
        capture_output=True,
        text=True
    )
    assert result.returncode == 0, f"Build failed: {result.stderr}"

def test_bindgen_generated_bindings():
    """Anti-cheat: Verify bindgen actually generated bindings."""
    build_dir = pathlib.Path("/app/target/release/build")
    assert build_dir.exists(), "Build directory not found"
    
    # Find bindings.rs files generated by bindgen
    bindings_files = list(build_dir.rglob("bindings.rs"))
    assert len(bindings_files) > 0, "bindgen did not generate bindings.rs files"

def test_binary_linked_against_openssl():
    """Anti-cheat: Verify binary is actually linked against OpenSSL from /opt/openssl (REQUIRED)."""
    binary_path = "/app/target/release/examples/https_client"
    if not os.path.exists(binary_path):
        binary_path = "/app/target/release/https_client"

    assert os.path.exists(binary_path), "Binary not found"

    # Check library dependencies using ldd - REQUIRED, no fallback
    result = subprocess.run(
        ["ldd", binary_path],
        capture_output=True,
        text=True,
        timeout=5
    )
    assert result.returncode == 0, "ldd command failed - cannot verify OpenSSL linking"

    output = result.stdout
    assert "libssl" in output or "libcrypto" in output, \
        "Binary not linked against OpenSSL libraries"

    # REQUIRED: Verify libraries are from /opt/openssl, NOT system OpenSSL
    assert "/opt/openssl" in output, \
        "Binary not linked against OpenSSL from /opt/openssl - found different OpenSSL installation"

    # Ensure it's NOT using system OpenSSL
    assert not re.search(r"/usr/lib.*libssl", output), \
        "Binary using system OpenSSL instead of /opt/openssl"

def test_openssl_libraries_exist():
    """Anti-cheat: Verify OpenSSL libraries exist in expected location."""
    openssl_lib_dir = pathlib.Path("/opt/openssl/lib")
    assert openssl_lib_dir.exists(), "OpenSSL lib directory not found"
    
    # Check for libssl
    libssl_files = list(openssl_lib_dir.glob("libssl.so*"))
    assert len(libssl_files) > 0, "libssl.so not found in /opt/openssl/lib"
    
    # Check for libcrypto
    libcrypto_files = list(openssl_lib_dir.glob("libcrypto.so*"))
    assert len(libcrypto_files) > 0, "libcrypto.so not found in /opt/openssl/lib"

def test_llvm_14_installed():
    """Anti-cheat: Verify LLVM 14 is installed AND actually used (not just 13 or 15)."""
    llvm14_paths = [
        "/usr/lib/llvm-14",
        "/usr/lib/x86_64-linux-gnu/llvm-14"
    ]
    assert any(os.path.exists(p) for p in llvm14_paths), \
        "LLVM 14 not found - incorrect version may have been used"

    # Verify LLVM 14's libclang was actually available during build
    libclang_paths = [
        "/usr/lib/llvm-14/lib/libclang.so",
        "/usr/lib/x86_64-linux-gnu/libclang-14.so.1"
    ]
    assert any(os.path.exists(p) for p in libclang_paths), \
        "LLVM 14 libclang not found - bindgen may have used wrong version"

    # Check build output for evidence of LLVM/clang version used
    build_dir = pathlib.Path("/app/target/release/build")
    if build_dir.exists():
        # Look for build output that mentions clang version
        for output_file in build_dir.rglob("output"):
            try:
                with open(output_file, 'r') as f:
                    content = f.read()
                    if "clang version" in content:
                        # If we found version info, verify it's version 14
                        assert "clang version 14" in content, \
                            f"Build used wrong clang version (not 14): {content}"
                        break
            except Exception:
                pass
        for stderr_file in build_dir.rglob("stderr"):
            try:
                with open(stderr_file, 'r') as f:
                    content = f.read()
                    if "clang version" in content:
                        # If we found version info, verify it's version 14
                        assert "clang version 14" in content, \
                            f"Build used wrong clang version (not 14): {content}"
                        break
            except Exception:
                pass

def test_https_client_runs():
    """Verify HTTPS client example executes successfully."""
    result = subprocess.run(
        ["cargo", "run", "--release", "--example", "https_client"],
        cwd="/app",
        capture_output=True,
        text=True,
        timeout=30
    )
    assert result.returncode == 0, f"Example failed: {result.stderr}"
    return result.stdout + result.stderr

def test_tls_connection_established():
    """Verify TLS connection was successfully established."""
    output = test_https_client_runs()
    assert "Successfully connected to https://www.rust-lang.org" in output, \
        "Success message not found in output"

def test_tls_version_valid():
    """Verify TLS version is 1.2 or higher."""
    output = test_https_client_runs()
    tls_match = re.search(r"TLS version: TLSv1\.([23])", output)
    assert tls_match is not None, "Valid TLS version not found in output"

def test_real_http_response():
    """Anti-cheat: Verify actual HTTP response was received (ALL checks required)."""
    output = test_https_client_runs()

    # ALL checks must pass (not 2/4)

    # Check 1: REQUIRED - HTML tags
    assert re.search(r"<!DOCTYPE|<html", output, re.IGNORECASE), \
        "No HTML tags found in output"

    # Check 2: REQUIRED - rust-lang specific content
    assert re.search(r"rust-lang|rustlang|Rust", output, re.IGNORECASE), \
        "No rust-lang.org content found"

    # Check 3: REQUIRED - Complete HTML tag pairs
    assert re.search(r"<[a-z]+[^>]*>", output, re.IGNORECASE), \
        "No opening HTML tags found"
    assert re.search(r"</[a-z]+>", output, re.IGNORECASE), \
        "No closing HTML tags found"

    # Check 4: REQUIRED - Minimum 500 characters (not 200)
    assert len(output) >= 500, \
        f"Output too short: {len(output)} chars (expected >=500 for real webpage)"

def test_pkg_config_files_created():
    """Anti-cheat: Verify pkg-config files were created for OpenSSL."""
    openssl_pc = pathlib.Path("/opt/openssl/lib/pkgconfig/openssl.pc")
    assert openssl_pc.exists(), "pkg-config file for OpenSSL not found - OpenSSL may not be properly configured"

def test_openssl_symbols_in_binary():
    """Anti-cheat: Verify OpenSSL symbols are present in binary (REQUIRED)."""
    binary_path = "/app/target/release/examples/https_client"
    if not os.path.exists(binary_path):
        binary_path = "/app/target/release/https_client"

    assert os.path.exists(binary_path), "Binary not found"

    # Check for OpenSSL symbols that would be used in a real TLS connection
    # REQUIRED - no fallback
    result = subprocess.run(
        ["nm", "-D", binary_path],
        capture_output=True,
        text=True,
        timeout=5
    )
    assert result.returncode == 0, "nm command failed - cannot verify OpenSSL symbols"

    output = result.stdout
    symbol_count = 0

    # Check for critical OpenSSL symbols
    if "SSL_connect" in output:
        symbol_count += 1
    if "SSL_CTX_new" in output:
        symbol_count += 1
    if "SSL_read" in output or "SSL_write" in output:
        symbol_count += 1

    assert symbol_count >= 2, \
        f"Insufficient OpenSSL symbols found in binary (found {symbol_count}/3 expected)"

def test_network_syscalls_occurred():
    """Anti-cheat: Verify actual network syscalls occurred (REQUIRED - strongest verification)."""
    import tempfile

    binary_path = "/app/target/release/examples/https_client"
    if not os.path.exists(binary_path):
        binary_path = "/app/target/release/https_client"

    assert os.path.exists(binary_path), "Binary not found"

    # Run the binary under strace to capture syscalls
    # REQUIRED - no fallback
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.log', delete=False) as strace_log:
        strace_log_path = strace_log.name

    try:
        subprocess.run(
            ["strace", "-e", "trace=network,connect,sendto,recvfrom,send,recv,read,write",
             "-o", strace_log_path,
             binary_path],
            capture_output=True,
            text=True,
            timeout=30
        )

        # Read the strace log
        with open(strace_log_path, 'r') as f:
            strace_output = f.read()

        # ALL network checks are REQUIRED (no fallbacks)
        # Verify actual network connection was established
        assert re.search(r"connect\(.*AF_INET", strace_output), \
            "No network connection detected in syscalls - output may be spoofed"

        # Verify data was sent
        assert re.search(r"(sendto|send|write)\([0-9]+", strace_output), \
            "No data sent over network - output may be spoofed"

        # Verify data was received
        assert re.search(r"(recvfrom|recv|read)\([0-9]+", strace_output), \
            "No data received from network - output may be spoofed"

    finally:
        # Clean up temp file
        if os.path.exists(strace_log_path):
            os.unlink(strace_log_path)
